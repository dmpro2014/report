\chapter{GPU}

The GPU is at the heart of the Demolicious system.
Inspired by SIMD and SIMT architecture and programming models, the GPU architecture is named 'GhettoCUDA' in honor of NVIDIAs CUDA environment.\todo{cite this}

The GhettoCUDA architecture is highly parallel, in that it allows for a great number of threads to execute in parallel on multiple streaming processors.
A thread is the unit of execution, in essence a single procedure, that when correctly parameterized by run-time values allows for the transformation of a set of input data to a graphical representation to be visualized by the HDMI module.
A simple kernel, requiring no input, might be one that for each pixel in the framebuffer stores the color red.

The main design challenge in creating a GPU-inspired system is managing to saturate the memory bus as much as possible, changing memory access patterns from clustering together in time to a more spread-out pattern.
To facilitate this, the architecture allowing for multiple threads to execute on each streaming processor core, with a staggered start.
This design decision allows for a steady stream of load/store instructions without requiring a system stall as one waits for memory requests to return.

\section{Responsibilities}

The GPU has a relatively simple job:
\begin{enumerate}
  \item
    Receive instructions and constant data from the MCU
  \item
    Receive kernel invokations from the MCU
  \item
    Write results to external SRAM
  \item
    Assert the 'computation finished' signal to the MCU
\end{enumerate}

\section{Kernel Structure}



\section{Receiving a Kernel Call}
\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{gpu/diagrams/receiving_a_kernel_call.png}
\caption{Launcing a kernel, from the GPU's viewpoint.}
\label{kernel_call}
\end{figure}
The communication unit is responsible for receiving kernel call requests from the CPU, and initiating the request.
A valid kernel call consists of the address of the kernel, the number of batches to launch, and asserting the launch signal.

The kernel launch signals are forwarded to the GPU, which initiates the kernel internally. 
After holding the kernel launch signals high for one clock cycle, the communication unit has completed its role in launching the kernel, and the GPU will run the kernel to completion.
When the kernel completes executing the GPU asserts the kernel done signal, and the communication unit forwards the signal to the CPU indicating that the kernel call has completed.


\section{Running a Kernel}

\section{Architecture Overview}

\section{Component Details}

\subsection{Streaming Processor}

The streaming processor is at the heart of the GhettoCUDA architecture.
A fully operational GhettoCUDA processor will have up to 32 streaming processors wired up, allowing for an extreme degree of parallelism in code execution.

The architecture of the streaming processor is inspired by the cores of the MIPS architecture.
They consist of a single ALU, a register bank, as well as logic for reading operands from thread-private registers, shared external memory and constant storage.
Each register bank is actually composed of several register files, containing a number of general- and special purpose registers.
The register bank mirrors the interface of the register file, but only exposes a single register file at a time, which one decided by the current active barrel line.
This system allows rapid context switching between the plethora of threads co-existing inside each streaming processor.

The streaming processor support conditional execution of instructions, using a dedicated mask register to decide whether instructions should be executed or not.
This allows for branch-like behaviour without having to support the complex logic required for diverging threads.

When a memory request is invoked by the currently active instruction, memory addresses and data values are sampled from the currently active register file in the register directory, and passed on to the load/store unit.
Dedicated address and data store/return registers allows for simplification of both the programming model as well as requiring fewer wires between the set of streaming processors and the load/store unit.

\subsection{Thread Spawner}

The thread spawner is responsible for converting the MCUs request of n kernels executing kernel k on dataset d to actual hardware threads.
As all kernels are uniquely identifiable by their respective thread ID, the thread spawner is responsible for providing strictly increasing and unique IDs.


\subsection{Register Directory}

\subsection{Load/Store Unit}

