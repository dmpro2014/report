\documentclass[../main/report.tex]{subfiles}
\begin{document}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{../system_overview/diagrams/programming_model_cpu_gpu.png}
	\caption{Relationship between CPU and GPU code.}
	\label{fig:programming_model_cpu_gpu}
\end{figure}

\todo{That sentence is a bit dangling and not part of the rest of the chapter. Maybe talk more about CUDA/OpenCL before we start explaining?}
The programming model for Demolicious has been heavily inspired by CUDA and OpenCL, 
and readers with programming experience with those technologies will find much of this chapter familiar.

Many applications can be divided into sequential and parallel parts,
where the characteristics of each part make them benefit from different hardware.
On the Demolicious system, the sequential parts of a program will be run by the CPU, and the parallel parts can be performed by the GPU through kernels.
\todo{Mention SIMT}
A kernel is a simple program meant to be executed by multiple threads.
The kernels are uploaded to the GPU, and then executed when requested by the CPU.
This interaction allows for programs that consist of both parallel and sequential tasks, such as graphics applications.
\todo{Replace last sentence}

\subsection{Kernels}
The GPU can start a massive amount of threads executing the same kernel.
Each thread executing the kernel is assigned a unique thread id.
The thread id can be used to compute memory addresses and make control decisions
to make the threads behave differently even though they are executing the same code. 
\todo{See masking. Do/should we have a subchapter about masking?}

\begin{assembly}
ldi $data, 0b1111111111111111
mv $address_lo, $id_lo
mv $address_hi, $id_hi
sw
thread_finished
\end{assembly}

Kernels can take parameters as input, which lets them be reused with varying output.
The CPU can set these parameters to different values each time a kernel is run.
For instance, the CPU can set the vertices of a triangle,
and the kernel could use them to render a triangle on screen.
Following is an update of the example kernel where the color is stored as a parameter:

\begin{assembly}
ldc, $data, 0
mv $address_lo, $id_lo
mv $address_hi, $id_hi
sw
thread_finished
\end{assembly}

Different threads can also give different output for the same kernel.
Using their ID and ALU operations, they can easily generate interesting patterns.

\begin{assembly}
ldc $data, 0
sub $data, $data, $id_lo
mv $address_lo, $id_lo
mv $address_hi, $id_hi
sw
\end{assembly}

The instruction set available to kernels is fairly limited.
Most notably, the control flow in kernels is linear, meaning they cannot do any branches or jumps.
Although the kernels don't support diverging control flow,
conditional execution is accomplished through predicated instructions.

Each of the instructions in the instruction set can be executed conditionally by prefixing them with \emph{?}.
Whether a conditional instruction is executed is controlled by a dedicated masking register.
The programmer may use arithmetic and logic operations to manipulate this register (such as the slt instruction in figure \ref{fig:conditional_execution}).
The mask register is only one bit, so only the least significant bit of data written to it will be stored.
A masked instruction is not executed if the mask register is \textbf{1}.

\begin{assembly}
ldc $10, 0 ; Load color one
ldc $11, 1 ; Load color two
srl $mask, $id_lo, 10 ; Shift to the right converts ID to y pos
mv $data, $10 
? mv $data, $11 ; Will only be executed every other row
mv $address_lo, $id_lo
mv $address_hi, $id_hi
sw
thread_finished
\end{assembly}

All kernels must end with the instruction \verb/thread_finished/.
This tells the GPU to stop executing the thread, and start the next one.

\todo{Talk about memory and cooldown}

\end{document}
