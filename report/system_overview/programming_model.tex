\documentclass[../main/report.tex]{subfiles}
\begin{document}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{../system_overview/diagrams/programming_model_cpu_gpu.png}
	\caption{Relationship between CPU and GPU code.}
	\label{fig:programming_model_cpu_gpu}
\end{figure}

\todo{That sentence is a bit dangling and not part of the rest of the chapter. Maybe talk more about CUDA/OpenCL before we start explaining?}
The programming model for Demolicious has been heavily inspired by CUDA and OpenCL, 
and readers with programming experience with those technologies will find much of this chapter familiar.

Many applications can be divided into sequential and parallel parts,
where the characteristics of each part make them benefit from different hardware.
On the Demolicious system, the sequential parts of a program will be run by the CPU, and the parallel parts can be performed by the GPU through kernels.
\todo{Mention SIMT}
A kernel is a simple program meant to be executed by multiple threads.
The kernels are uploaded to the GPU, and then executed when requested by the CPU.
This interaction allows for programs that consist of both parallel and sequential tasks, such as graphics applications.
\todo{Replace last sentence}

\subsection{Kernels}
The GPU can start a massive amount of threads executing the same kernel.
Each thread executing the kernel is assigned a unique thread id.
The thread id can be used to compute memory addresses and make control decisions
to make the threads behave differently even though they are executing the same code. 
\todo{See masking. Do/should we have a subchapter about masking?}


To best illustrate the programming model, a few examples will be walked through. 
Let's start with a simple one; fill the screen with the color green.
We assume that the pixel color values are stored in memory from location 0.
In a sequential programming model one would typically write a loop that would fill
the memory locations with the value for green one by one. 
See listing \ref{sequential-green}.

\begin{c-code}[caption=A sequential program filling the screen with green, label=sequential-green]
int green = 0x00FF00;
for (int i = 0; i < nr_of_pixels; i++){
	write(i, green);
}
\end{c-code}

However, in the SIMT programming paradigm our architecture is inspired by,
you write a \emph{kernel} that fills only a single pixel with green, 
and then run it with one thread for every pixel.
Below, in listing \ref{lst:green-kernel}, 
you see a kernel written for Demolicious that fills a single memory location,
or pixel, with green.
The memory location to be written to is decided by the special id register. 


\begin{assembly}[caption=A simple kernel that fills the screen with the color green, label=lst:green-kernel]
ldi $data, 0b0000011111100000
mv $address_lo, $id_lo
mv $address_hi, $id_hi
sw
thread_finished
\end{assembly}

Let's walk through the kernel one line at a time.
The first uses the \textbf{ldi} instruction, which stands for load immediate.
It loads the value 0b0000011111100000,
which corresponds to the color green in the Demolicious color space,
into the special register \textbf{\$data}.
How it is used will become clear later.
The second and third line move the kernel's thread ID into the address registers.
This means all pixels starting with address zero and up until the number of executed threads
will get colored green.
Finally, the store instruction is executed, storing the value in the \$data register
to the address given by the two address registers.
The thread stops running after executing the \verb/thread_finished/ instruction.

Kernels can take parameters as input, which lets them be reused with varying output.
The CPU can set these parameters to different values each time a kernel is run.
For instance, the CPU can set the vertices of a triangle,
and the kernel could use them to render a triangle on screen.
Following is an update of the example kernel where the color is stored as a parameter:

\begin{assembly}
ldc, $data, 0
mv $address_lo, $id_lo
mv $address_hi, $id_hi
sw
thread_finished
\end{assembly}

%Different threads can also give different output for the same kernel.
%Using their ID and ALU operations, they can easily generate interesting patterns.

The instruction set available to kernels is fairly limited.
Most notably, the control flow in kernels is linear, meaning they cannot do any branches or jumps.
Although the kernels don't support diverging control flow,
conditional execution is accomplished through predicated instructions.

Each of the instructions in the instruction set can be executed conditionally by prefixing them with \emph{?}.
Whether a conditional instruction is executed is controlled by a dedicated masking register.
The programmer may use arithmetic and logic operations to manipulate this register (such as the slt instruction in figure \ref{fig:conditional_execution}).
The mask register is only one bit, so only the least significant bit of data written to it will be stored.
A masked instruction is not executed if the mask register is \textbf{1}.

\begin{assembly}
ldc $10, 0 ; Load color one
ldc $11, 1 ; Load color two
srl $mask, $id_lo, 10 ; Shift to the right converts ID to y pos
mv $data, $10 
? mv $data, $11 ; Will only be executed every other row
mv $address_lo, $id_lo
mv $address_hi, $id_hi
sw
thread_finished
\end{assembly}

All kernels must end with the instruction \verb/thread_finished/.
This tells the GPU to stop executing the thread, and start the next one.

\todo{Talk about memory and cooldown}

\end{document}
