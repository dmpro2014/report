\documentclass[../main/report.tex]{subfiles}
\begin{document}

\section{Static resource management by means of\\
Barrels and Jaktstart}

Assume that when a processor executes a memory operation, a few extra cycles need to pass before the response arrives.
This might happen because the memory needs more time to respond than the processor needs for other instructions.
The processor might stall while this happens to hide the delay and make sure the result of the request ready before the next instruction.
The processor may also not stall so that it can continue to do useful work.
It is then expected that the program does not use the result of the memory operation before a sufficient number of cycles pass.
If there is no useful work to be done before the result is known, the program needs to idle.

It would be good for throughput if the processor did not ever need to be idle.
And indeed, if the program is multithreaded, the processor could work on another thread while waiting for response from the memory.
If the time needed to complete a memory request is spent in other threads, the memory operation appears to have taken only one instruction, wasting no time on idling.
A simple scheme to accomplish this is to change threads after every instruction.
There is a thread pool the same size as the number of instructions that pass from start to finish of a memory request.
The threads take turn executing in a circular fashion, such that the threads are resumed after just enough time to complete a memory request.
This concept is called \emph{barrel processing} and is a type of \emph{static scheduling}.

The memory would need to be able to complete one request by every thread-change.
This is because even if all the threads access memory one after another, the results should still be ready by the next time they run.
But a request \emph{can} take more than one instruction's time to be processed as some types of memory can \emph{start} to process a request before the previous few are finished.
This is (with some slight simplification) how modern SDRAM works, and it is called \emph{pipelining} the memory.

When barrel processing was incorporated in the early design of the Demolicious, the assumption was made that SRAM has, like SDRAM, is pipelined.
However, Demolicious also had multiple streaming processors, all of which make requests to memory simultaneously.
With these two features combined, the memory would now have to be able to start one request for every streaming processor on every warp switch, which happens every cycle.
This would mean running the memory at a higher clock speed than the processor, which would mean slowing down the processor.
Slowing down the processor would not serve to increase throughput, which was the reason for the barrels in the first place.

At that point in the design of Demolicious, all warps ran the same instruction.
That means that all the memory request would always have come one after another and would have to be put in a gigantic queue.
The requests would not be done in time for all the warps, and since the same instruction has to be executed on all the warps, the warps that did get a benefit from the barrel processing would have to wait for the rest.
In any case, the SRAM memory used was not pipelined, but was in fact asynchronous, thus eliminating the purpose of the barrels.
The barrel processor seemed to be a useless complication, a failure in this hardware combination.

To solve the issue of generating more memory request than can be handled, \emph{jaktstart} was introduced.
Now each consecutive warp executes one instruction later than the previous.
The barrel now serves to allow the completion of one warp's requests.
Since the next warp is delayed by a instruction, it will not issue requests before the previous were done.
This works out and the latency is hidden, allowing optimal utilization of the processor, as long as the program does not use the memory ``too often''.
The usage of memory operations must be limited to one per barrel-size number of instructions.
The barrel-size must be large enough to allow the memory to service the requests from a single warp.

\end{document}
