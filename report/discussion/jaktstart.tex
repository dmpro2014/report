\documentclass[../main/report.tex]{subfiles}
\begin{document}

\section{Static resource management by means of\\
Barrels and Jaktstart}

Usually, when a processor executes a memory operation, a few extra cycles need to pass before the response arrives.
The processor might stall while this happens to hide the wait and make the result of the request ready in the next instruction.
It may also not stall so that the processor can continue to do useful work, but it is then expected that the program does not use the result of the memory operation before a sufficient number of cycles pass.

If a processor stalls when doing a memory operation, some cycles will obviously be lost to that.
Even if it continues on to the next instruction, if the result of the memory is needed to continue, the processor needs to be stalled by the program.
It would be good for throughput if the processor did not ever need to be idle.
And indeed, if the program is multithreaded, the processor could work on another thread while waiting for response from the memory.
If the time needed to complete a memory request is spent in other threads, the memory operation appears to have taken only one instruction.
A simple scheme to accomplish this is to change threads after every instruction.
There is a thread pool the same size as the number of instructions that pass from start to finish of a memory request.
The threads take turn executing in a circular fashion, and control is returned to a thread just after a potential memory request would have completed.
This concept is called \emph{barrel processing} and is a type of \emph{static scheduling}.

Of course, with barrel processing, the memory would need to be able to complete one request for every instruction.
But a request \emph{can} take more than one instruction's time to be processed, if the memory can \emph{start} to process one request per instruction.
This is (with some slight simplification) how modern SDRAM works, and it is called \emph{pipelining} the memory.

Since barrel processing is a good thing\texttrademark, it was incorporated in the early design of the Demolicious.
The assumption was made that SRAM has, like SDRAM (which after all is only a letters difference\todo{Remove this. It's getting late.}) a latency higher than the time it takes to make a request and is pipelined.
Now the problem that Demolicious also has simultaneous multiprocessing by having multiple streaming processors, and all of these make requests to the same memory simultaneously.
The memory would now have to be able to start one request for every streaming processor for every instruction that take one cycle each.
This would mean running the memory at a higher clock speed than the processor, which would mean slowing down the processor.
Slowing down the processor would not serve to increase throughput, which was the reason for the barrels in the first place.

At this point, all the threads in the barrel's thread pool in the Demolicious' design run the same instruction.
That means that all the memory request would always come one after another and would have to be put in a gigantic queue.
The requests would not be done in time for all the warps, and since the same instruction has to be executed on all the warps, the warps that did get a benefit from the barrel processing would have to wait for the rest.
In any case, the SRAM memory used was not pipelined, but was in fact asynchronous, thus eliminating the purpose of the barrels.
The barrel processor seemed to be a useless complication, a failure in this hardware combination.

To solve the issue of generating more memory request than can be handled, \emph{jaktstart} was introduced.
Now each consecutive warp executes one instruction later than the previous.
The barrel now serves to allow the completion of one warp's requests.
Since the next warp is delayed by a instruction, it will not issue requests before the previous were done.
This works out and the latency is hidden, allowing optimal utilization of the processor, as long as the program does not use the memory ``too often''.

\end{document}
